<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>2D Wave PINN ¬∑ Portfolio Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="app-shell">
    <!-- Top navigation / branding -->
    <header class="site-header">
      <div class="brand">
        <div class="brand-mark">AB</div>
        <div class="brand-text">
          <span class="brand-name">Avery Bradley</span>
          <span class="brand-tagline">Applied Math ¬∑ ML Engineering</span>
        </div>
      </div>
      <nav class="site-nav">
        <a href="#top">Demo</a>
        <a href="#overview">Overview</a>
        <a href="#methods">Methods</a>
        <a href="#results">Results</a>
      </nav>
    </header>

    <!-- Hero + main visualization -->
    <main class="main-content" id="top">
      <section class="hero">
        <div class="hero-text">
          <div class="eyebrow">Physics-Informed Neural Networks ¬∑ PDEs ¬∑ Visualization</div>
          <h1 class="hero-title">
            2D Wave Equation<br />
            <span class="hero-highlight">PINN vs Finite Difference</span>
          </h1>
          <p class="hero-description">
            A physics-informed neural network (PINN) learns the dynamics of a
            2D wave on a square ‚Äúocean patch,‚Äù and is validated against a
            classical finite-difference solver. Use the interactive viewer to
            explore the wave field across space and time.
          </p>

          <div class="hero-badges">
            <span class="badge badge-pill">PyTorch</span>
            <span class="badge badge-pill">Numerical PDEs</span>
            <span class="badge badge-pill">Plotly.js</span>
            <span class="badge badge-pill">Scientific Computing</span>
          </div>

          <div class="hero-actions">
            <!-- Replace hrefs with your real links -->
            <a class="btn btn-primary" href="https://github.com/" target="_blank" rel="noreferrer">
              View Code on GitHub
            </a>
            <a class="btn btn-ghost" href="#overview">
              Read the Project Overview
            </a>
          </div>

          <div class="hero-meta">
            <div class="meta-item">
              <span class="meta-label">Domain</span>
              <span class="meta-value">2D Wave PDE</span>
            </div>
            <div class="meta-item">
              <span class="meta-label">Training Signal</span>
              <span class="meta-value">PDE + IC + BC</span>
            </div>
            <div class="meta-item">
              <span class="meta-label">Comparison</span>
              <span class="meta-value">PINN vs FD baseline</span>
            </div>
          </div>
        </div>

        <!-- Visualization panel -->
        <div class="hero-panel">
          <div class="panel-header">
            <div>
              <h2 class="panel-title">Interactive Wave Viewer</h2>
              <p class="panel-subtitle">
                Scrub through time, switch between solvers,
                and inspect the learned dynamics.
              </p>
            </div>
            <span class="panel-chip">Live Demo</span>
          </div>

          <div class="control-bar">
            <div class="control-group">
              <label for="modeSelect">Field:</label>
              <select id="modeSelect">
                <option value="fd">Finite Difference</option>
                <option value="pinn">PINN</option>
                <option value="error">Error (PINN ‚àí FD)</option>
              </select>
            </div>

          <div class="control-group">
            <label style="font-weight: 500;">
              Time
              <span id="timeLabel" class="time-label">t = 0.000</span>
            </label>
          </div>

          </div>


          <div id="plot" class="plot-container"></div>

          <div class="panel-footer">
            <div class="legend">
              <span class="legend-dot legend-fd"></span> FD baseline
              <span class="legend-dot legend-pinn"></span> PINN prediction
              <span class="legend-dot legend-error"></span> Error field
            </div>
            <div id="frameInfo" class="frame-info">
              Loaded frames: <span id="frameCount">‚Äì</span>
            </div>
          </div>
        </div>
      </section>

      <!-- Overview section -->
      <section id="overview" class="section section-card">
        <div class="section-header">
          <h2>Project Overview</h2>
          <p>
            This project explores how Physics-Informed Neural Networks can learn
            the dynamics of a partial differential equation when the governing
            physics are known, and compares them to a classical numerical
            solver.
          </p>
        </div>

        <div class="section-grid">
          <div class="section-block">
            <h3>The PDE</h3>
            <p>
              We solve the 2D wave equation
              <em>u<sub>tt</sub> = c¬≤ (u<sub>xx</sub> + u<sub>yy</sub>)</em>
              on a 10 m √ó 10 m square domain <em>[0,10] √ó [0,10]</em>, with time
              <em>t ‚àà [0, T]</em>. The solution <em>u(t, x, y)</em> represents
              the vertical displacement of the water surface.
            </p>
            <p>
              The initial displacement is a Gaussian "bump" at the center of the
              domain, mimicking a localized disturbance such as a stone dropped
              into a still pond. Boundary values are clamped to zero, leading to
              reflections at the edges.
            </p>
          </div>

          <div class="section-block">
            <h3>What the PINN learns</h3>
            <p>
              The PINN receives points in spacetime <em>(t, x, y)</em> as input
              and outputs a scalar prediction <em>u(t, x, y)</em>. The loss
              function enforces:
            </p>
            <ul>
              <li>the wave equation residual in the interior,</li>
              <li>the initial Gaussian profile at <em>t = 0</em>,</li>
              <li>zero initial velocity, and</li>
              <li>zero displacement on the domain boundary.</li>
            </ul>
            <p>
              No ground-truth labels are provided in the interior; instead, the
              PDE and boundary conditions act as the training signal.
            </p>
          </div>
        </div>
      </section>

      <!-- Methods section -->
      <section id="methods" class="section section-card">
        <div class="section-header">
          <h2>Methods</h2>
          <p>
            The project combines classical numerical methods with deep learning
            to evaluate how well a neural network can approximate PDE
            solutions when guided by the governing physics.
          </p>
        </div>

        <div class="section-grid methods-grid">
          <div class="section-block">
            <h3>Finite Difference Baseline</h3>
            <p>
              The finite-difference (FD) solver uses a second-order scheme in
              both space and time:
            </p>
            <ul>
              <li>Central differences for spatial derivatives
                  <em>u<sub>xx</sub>, u<sub>yy</sub></em>,</li>
              <li>a leapfrog-style update for
                  <em>u<sub>tt</sub></em>,</li>
              <li>Dirichlet boundary conditions <em>u = 0</em> on all edges.</li>
            </ul>
            <p>
              The FD solution serves as a numerical "ground truth" for
              evaluating the PINN‚Äôs accuracy.
            </p>
          </div>

          <div class="section-block">
            <h3>Physics-Informed Neural Network</h3>
            <p>
              The PINN is implemented in PyTorch as a fully-connected network
              with smooth <em>tanh</em> activations. Automatic differentiation
              is used to compute time and spatial derivatives for the PDE
              residual:
            </p>
            <p class="equation">
              r<sub>Œ∏</sub>(t, x, y) =
              u<sub>tt</sub> ‚àí c¬≤ (u<sub>xx</sub> + u<sub>yy</sub>).
            </p>
            <p>
              Training minimizes a weighted sum of interior residual, initial
              displacement, initial velocity, and boundary losses.
            </p>
          </div>
        </div>
      </section>

      <!-- Results section -->
      <section id="results" class="section section-card">
        <div class="section-header">
          <h2>Results & Interpretation</h2>
          <p>
            The interactive viewer shows how the PINN‚Äôs solution compares to
            the FD baseline across the entire spacetime domain.
          </p>
        </div>

        <div class="results-grid">
          <div class="section-block">
            <h3>Qualitative behavior</h3>
            <p>
              For a wide range of timesteps, the PINN closely tracks the radial
              wavefronts and reflections at the boundaries. The global shape
              and phase of the wave field are captured accurately, even though
              the network never sees direct interior labels.
            </p>
          </div>

          <div class="section-block">
            <h3>Error structure</h3>
            <p>
              The error visualization highlights where the PINN struggles most,
              typically near boundaries and at later times where waves have
              reflected multiple times. This behavior is consistent with known
              challenges in approximating long-time dynamics for PDEs.
            </p>
          </div>

          <div class="section-block results-metrics">
            <h3>Example metrics</h3>
            <ul>
              <li><strong>Mean squared error (space‚Äìtime):</strong> fill-in</li>
              <li><strong>Max absolute error:</strong> fill-in</li>
              <li><strong>Grid size:</strong> fill-in</li>
              <li><strong>Number of collocation points:</strong> fill-in</li>
            </ul>
            <p class="note">
              Replace the placeholder values with metrics computed in your
              evaluation script.
            </p>
          </div>
        </div>
      </section>
    </main>

    <footer class="site-footer">
      <p>
        &copy; <span id="year"></span> Avery Bradley ¬∑
        <span class="footer-sep">¬∑</span>
        Built with Python, PyTorch, and Plotly.js
      </p>
    </footer>
  </div>

      <!-- <script type="module">  
        // Import Three.js from jsDelivr CDN  
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js';  
 
        // Test: Log Three.js to confirm it loaded
        console.log('Three.js loaded:', THREE);  
    </script>   -->
  <!-- <script type="module" src="script.js"></script> -->
   <script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';

  // ================================
  //  Backend-Driven Wave Simulator (Three.js)
  // ================================

  const BACKENDS = {
    render: "https://wave-pinn-solver.onrender.com",
    local: "http://localhost:8000",
  };
  

  const isLocalHost =
    window.location.hostname === "localhost" ||
    window.location.hostname === "127.0.0.1";

  // UI elements
  const timeLabelEl   = document.getElementById("timeLabel");
  const frameCountEl  = document.getElementById("frameCount");

  let frameCounter = 0;  // how many frames we‚Äôve pulled from the backend


  function resolveInitialBackend() {
    const urlBackend = new URLSearchParams(window.location.search).get("backend");
    if (urlBackend && BACKENDS[urlBackend]) return urlBackend;

    const stored = localStorage.getItem("backendTarget");
    if (stored && BACKENDS[stored]) return stored;

    return isLocalHost ? "local" : "render";
  }

  let backendTarget = resolveInitialBackend();

  function apiBase() {
    return BACKENDS[backendTarget];
  }

  function apiUrl(path) {
    return `${apiBase()}${path}`;
  }

  const Lx = 10.0;
  const Ly = 10.0;
  const HEIGHT_SCALE = 6.0; // exaggerate vertical displacement for visibility

  let plotInitialized = false;
  let Nx = 0;
  let Ny = 0;

  // Three.js scene elements
  let scene;
  let camera;
  let renderer;
  let controls;
  let mesh;
  let container;
  let raycaster;
  let positionAttribute;
  let colorAttribute;

  // ===========================================
  //  API calls to backend FastAPI wave solver
  // ===========================================

  async function apiReset() {
    await fetch(apiUrl("/reset"), { method: "POST" });
  }

  async function apiDrop(x, y, A = 0.2, sigma = 0.05) {
    await fetch(apiUrl("/drop"), {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x, y, A, sigma }),
    });
  }

  async function apiStep(steps = 1) {
    await fetch(apiUrl(`/step?steps=${steps}`), {
      method: "POST",
    });
  }

  async function apiGetFrame() {
    const res = await fetch(apiUrl("/frame"));
    return await res.json(); // { time, u, x, y }
  }

  // =================================================
  //  HELPERS
  // =================================================

  function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
  }

  function heightToColor(h) {
    // Map height -> simple blue->cyan->yellow palette
    const minH = -0.1;
    const maxH = 0.1;
    const t = clamp((h - minH) / (maxH - minH), 0, 1);

    const c1 = { r: 0.1, g: 0.2, b: 0.7 }; // low: deep blue
    const c2 = { r: 0.0, g: 0.8, b: 0.8 }; // mid: cyan
    const c3 = { r: 1.0, g: 0.9, b: 0.2 }; // high: yellow

    let r;
    let g;
    let b;
    if (t < 0.5) {
      const k = t * 2;
      r = c1.r + (c2.r - c1.r) * k;
      g = c1.g + (c2.g - c1.g) * k;
      b = c1.b + (c2.b - c1.b) * k;
    } else {
      const k = (t - 0.5) * 2;
      r = c2.r + (c3.r - c2.r) * k;
      g = c2.g + (c3.g - c2.g) * k;
      b = c2.b + (c3.b - c2.b) * k;
    }

    return { r, g, b };
  }

  // function updateSurfaceHeights(zData) {
  //   if (!mesh) return;

  //   const positions = positionAttribute.array;
  //   const colors = colorAttribute.array;

  //   for (let i = 0; i < Nx; i++) {
  //     for (let j = 0; j < Ny; j++) {
  //       const idx = i * Ny + j;
  //       const posIndex = idx * 3 + 2; // z component

  //       const h = zData[i][j] * HEIGHT_SCALE;
  //       positions[posIndex] = h;

  //       const { r, g, b } = heightToColor(zData[i][j]);
  //       const colorIndex = idx * 3;
  //       colors[colorIndex] = r;
  //       colors[colorIndex + 1] = g;
  //       colors[colorIndex + 2] = b;
  //     }
  //   }

  //   positionAttribute.needsUpdate = true;
  //   colorAttribute.needsUpdate = true;
  //   mesh.geometry.computeVertexNormals();
  // }

  function updateSurfaceHeights(zData) {
  if (!mesh) return;

  const positions = positionAttribute.array;
  const colors = colorAttribute.array;

  for (let i = 0; i < Nx; i++) {      // i = x index
    for (let j = 0; j < Ny; j++) {    // j = y index
      const idx = j * Nx + i;         // ‚úÖ correct vertex index
      const posIndex = idx * 3 + 2;   // z component

      const h = zData[i][j] * HEIGHT_SCALE;
      positions[posIndex] = h;

      const { r, g, b } = heightToColor(zData[i][j]);
      const colorIndex = idx * 3;
      colors[colorIndex]     = r;
      colors[colorIndex + 1] = g;
      colors[colorIndex + 2] = b;
    }
  }

  positionAttribute.needsUpdate = true;
  colorAttribute.needsUpdate = true;
  mesh.geometry.computeVertexNormals();
}


function createScene(initialZ) {
  container = document.getElementById("plot");
  if (!container) throw new Error("Missing #plot container");

  const width = container.clientWidth || 800;
  const height = container.clientHeight || 500;

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x020617);

  // Camera: z-up, looking at center of the patch
  camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 200);
  camera.position.set(Lx / 2, -Ly * 1.2, 18);   // back + above
  camera.up.set(0, 0, 1);                       // z-up
  camera.lookAt(Lx / 2, Ly / 2, 0);             // üëà KEY

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(width, height);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  container.innerHTML = "";
  container.appendChild(renderer.domElement);

  raycaster = new THREE.Raycaster();

  const geometry = new THREE.PlaneGeometry(Lx, Ly, Nx - 1, Ny - 1);
  geometry.translate(Lx / 2, Ly / 2, 0); // plane in z=0, [0,Lx]x[0,Ly]

  const colors = new Float32Array(Nx * Ny * 3);
  geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

  const material = new THREE.MeshStandardMaterial({
    vertexColors: true,
    flatShading: false,
    side: THREE.DoubleSide,
  });

  mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);

  positionAttribute = mesh.geometry.attributes.position;
  colorAttribute = mesh.geometry.attributes.color;
  updateSurfaceHeights(initialZ);

  const hemiLight = new THREE.HemisphereLight(0xb0c4ff, 0x0b1221, 0.9);
  scene.add(hemiLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
  dirLight.position.set(-Lx, -Ly, 25);
  scene.add(dirLight);

  const grid = new THREE.GridHelper(Math.max(Lx, Ly), 10, 0x1f2937, 0x1f2937);
  grid.rotation.x = Math.PI / 2;
  grid.position.set(Lx / 2, Ly / 2, -0.01);
  scene.add(grid);

  renderer.render(scene, camera);

  renderer.domElement.addEventListener("pointerdown", handlePointer);
  window.addEventListener("resize", onResize);
}


  function onResize() {
    if (!renderer || !camera || !container) return;
    const width = container.clientWidth || window.innerWidth;
    const height = container.clientHeight || window.innerHeight;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
  }

  function handlePointer(event) {
    if (!mesh || !container) return;

    const rect = renderer.domElement.getBoundingClientRect();
    const mouse = new THREE.Vector2();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObject(mesh);
    if (hits.length === 0) return;

    const point = hits[0].point;
    apiDrop(point.x, point.y, 0.2, 0.5).catch((err) => {
      console.error("Error calling /drop:", err);
    });
  }

  // Initialize scene using the first frame
  // async function initializePlot() {
  //   console.log("Initializing backend simulation...");

  //   await apiReset();
  //   const frame = await apiGetFrame(); // { u, x, y }

  //   const zData = frame.u;
  //   Nx = zData.length;
  //   Ny = zData[0].length;

  //   createScene(zData);
  //   plotInitialized = true;
  // }

  async function initializePlot() {
  console.log("Initializing backend simulation...");

  await apiReset();
  const frame = await apiGetFrame(); // { u, x, y, t }

  const zData = frame.u;
  Nx = zData.length;
  Ny = zData[0].length;

  createScene(zData);
  plotInitialized = true;

  frameCounter = 1;
  if (frameCountEl) frameCountEl.textContent = String(frameCounter);
  if (timeLabelEl && typeof frame.t === "number") {
    timeLabelEl.textContent = `t = ${frame.t.toFixed(3)}`;
  }
}


  // Continuous animation loop
  // async function animateLoop() {
  //   if (plotInitialized) {
  //     try {
  //       await apiStep(1); // adjust steps for speed
  //       const frame = await apiGetFrame();
  //       updateSurfaceHeights(frame.u);
  //     } catch (err) {
  //       console.error("Error in animation loop:", err);
  //     }
  //   }

  //   if (renderer && scene && camera) {
  //     renderer.render(scene, camera);
  //   }

  //   requestAnimationFrame(animateLoop);
  // }

  async function animateLoop() {
  if (plotInitialized) {
    try {
      // Do a few simulation steps per render to reduce HTTP chatter
      await apiStep(5);
      const frame = await apiGetFrame();
      updateSurfaceHeights(frame.u);

      frameCounter += 1;
      if (frameCountEl) frameCountEl.textContent = String(frameCounter);
      if (timeLabelEl && typeof frame.t === "number") {
        timeLabelEl.textContent = `t = ${frame.t.toFixed(3)}`;
      }
    } catch (err) {
      console.error("Error in animation loop:", err);
    }
  }

  if (renderer && scene && camera) {
    renderer.render(scene, camera);
  }

  requestAnimationFrame(animateLoop);
}


  window.addEventListener("load", async () => {
    try {
      await initializePlot();
      requestAnimationFrame(animateLoop);
    } catch (err) {
      console.error("Failed to initialize Three.js viewer:", err);
    }
  });

  function setBackend(target) {
    if (!BACKENDS[target]) {
      console.warn(`Unknown backend: ${target}`);
      return;
    }

    if (backendTarget === target) return;

    backendTarget = target;
    localStorage.setItem("backendTarget", target);

    const select = document.getElementById("backendSelect");
    if (select) select.value = target;

    plotInitialized = false;

    initializePlot().catch((err) => {
      console.error(`Failed to initialize backend ${target}:`, err);
    });
  }

  document.getElementById("backendSelect")?.addEventListener("change", (evt) => {
    setBackend(evt.target.value);
  });

  const backendSelect = document.getElementById("backendSelect");
  if (backendSelect) {
    backendSelect.value = backendTarget;
  }
</script>

</html>
